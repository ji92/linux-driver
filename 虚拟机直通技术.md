# 什么是直通

# 为什么要直通

# 直通有哪些技术

vfio(virtual function io)直通和SR-IOV

# 虚拟机直通技术分为PCI passthrough和SR-IOV两种

PCI直通式使用host的物理网卡提供虚拟机使用，会占用一个网口。SR-IOV虚拟一个物理网卡为多个虚拟网卡，同时提供给多个虚拟机使用
`前置条件:`打开IOMMU功能

# SR-IOV

# PCI直通

## IOMMU

### IOMMU功能简介

IOMMU主要功能包括 `DMA Remapping`和 `Interrupt Remapping`，这里主要讲解DMA Remapping，Interrupt Remapping会独立讲解。对于DMA Remapping，IOMMU与MMU类似。IOMMU可以将一个设备访问地址转换为存储器地址，下图针对有无IOMMU情况说明IOMMU作用。
![](https://raw.githubusercontent.com/ji92/markdown_picture/master/images/20230904221649.png)
在没有IOMMU的情况下，网卡接收数据时地址转换流程，RC会将网卡请求写入地址addr1直接发送到DDR控制器，然后访问DRAM上的addr1地址，这里的RC对网卡请求地址不做任何转换，网卡访问的地址必须是物理地址。
![](https://raw.githubusercontent.com/ji92/markdown_picture/master/images/20230904221726.png)
对于有IOMMU的情况，网卡请求写入地址addr1会被IOMMU转换为addr2，然后发送到DDR控制器，最终访问的是DRAM上addr2地址，网卡访问的地址addr1会被IOMMU转换成真正的物理地址addr2，这里可以将addr1理解为虚机地址。
![](https://raw.githubusercontent.com/ji92/markdown_picture/master/images/20230904221816.png)
左图是没有IOMMU的情况，对于此种情况虚机无法实现设备的透传，原因主要有两个：
+ **在没有IOMMU的情况下，设备必须访问真实的物理地址HPA，而虚机可见的是GPA**
    【注】透传其实就是Guest OS和Host OS直接进行交互，不用VMM进行转译。地址不一致不能直接进行交互。
+ **如果让虚机填入真正的HPA，那样的话相当于虚机可以直接访问物理地址，会有安全隐患**
    【注】Guest OS之间相互隔离

所以针对没有IOMMU的情况，不能用透传的方式，对于设备的直接访问都会有VMM接管，这样就不会对虚机暴露HPA.

右图是有IOMMU的情况，虚机可以将GPA直接写入到设备，当设备进行DMA传输时，设备请求地址GPA由IOMMU转换为HPA（硬件自动完成），进而DMA操作真实的物理空间。IOMMU的映射关系是由VMM维护的，HPA对虚机不可见，保障了安全问题，利用IOMMU可实现设备的透传。这里先留一个问题，既然IOMMU可以将设备访问地址映射成真实的物理地址，那么对于右图中的Device A和Device B，IOMMU必须保证两个设备映射后的物理空间不能存在交集，否则两个虚机可以相互干扰，这和IOMMU的映射原理有关，后面会详细介绍。

### IOMMU作用
+ 屏蔽物理地址，起到保护作用。典型应用包括两个：
  + 一是实现用户态驱动，由于IOMMU的映射功能，使HPA对用户空间不可见，在vfio部分还会举例。
  + 二是将设备透传给虚机，使HPA对虚机不可见，并将GPA映射为HPA。
  【疑问】设备用户态驱动里可以配置GPA，虚机使用相同的GPA，GPA到HPA映射是VMM做的，和iommu没啥关系
+ IOMMU可以将连续的虚拟地址映射到不连续的多个物理内存片段，这部分功能于MMU类似，对于没有IOMMU的情况，设备访问的物理空间必须是连续的，IOMMU可有效的解决这个问题。
  【注】设备一般都是base addr + offset访问，没有复杂的内存映射机制

### IOMMU工作原理
前面简单介绍了IOMMU的映射功能，下面讲述IOMMU到底如何实现映射的，为便于分析，这里先不考虑虚拟化的场景，以下图为例，阐述工作原理。
![](https://raw.githubusercontent.com/ji92/markdown_picture/master/images/20230904223755.png)
IOMMU的主要功能就是完成映射，类比MMU利用页表实现VA->PA的映射，IOMMU也需要用到页表，那么下一个问题就是如何找到页表。在设备发起DMA请求时，会将自己的Source Identifier(包含Bus、Device、Func)包含在请求中，IOMMU根据这个标识，以RTADDR_REG指向空间为基地址，然后利用Bus、Device、Func在Context Table中找到对应的Context Entry，即页表首地址，然后利用页表即可将设备请求的虚拟地址翻译成物理地址。这里做以下说明：

图中红线的部门，是两个Context Entry指向了同一个页表。这种情况在虚拟化场景中的典型用法就是这两个Context Entry对应的不同PCIe设备属于同一个虚机，那样IOMMU在将GPA->HPA过程中要遵循同一规则；

由图中可知，每个具有Source Identifier(包含Bus、Device、Func)的设备都会具有一个Context Entry。如果不这样做，所有设备共用同一个页表，隶属于不同虚机的不同GPA就会翻译成相同HPA，会产生问题。

有了页表之后，就可以按照MMU那样进行地址映射工作了，这里也支持不同页大小的映射，包括4KB、2MB、1GB，不同页大小对应的级数也不同，下图以4KB页大小为例说明，映射过程和MMU类似，不再详细阐述。
![](https://raw.githubusercontent.com/ji92/markdown_picture/master/images/20230904223908.png)

以网卡为例，配置虚机中的xml文件，指定host上的BDF号，再输入虚机中的网卡BDF号即可
如果是SR-IOV，驱动需要做对应的修改，增加vf驱动。驱动安装后，查询网口的时候自然会出现多个网口

# 参考资料

+ [深度剖析IOMMU与VFIO技术架构](https://zhuanlan.zhihu.com/p/550698319)

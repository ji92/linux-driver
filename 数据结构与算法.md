# 数据结构 & 算法（C）

## 数组

### 二分查找

+ 前提：有序数组且无重复元素
+ **二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是循环不变量规则。**
+ [螺旋矩阵II](https://programmercarl.com/0059.%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE)也是循环不变量的一个例子

```c
// (版本一) 左闭右闭区间 [left, right] 建议使用
int search(int* nums, int numsSize, int target){
    int left = 0;
    int right = numsSize-1;
    int middle = 0;
    //若left小于等于right，说明区间中元素不为0
    while(left<=right) {
        //更新查找下标middle的值
        middle = (left+right)/2;
        //此时target可能会在[left,middle-1]区间中
        if(nums[middle] > target) {
            right = middle-1;
        } 
        //此时target可能会在[middle+1,right]区间中
        else if(nums[middle] < target) {
            left = middle+1;
        } 
        //当前下标元素等于target值时，返回middle
        else if(nums[middle] == target){
            return middle;
        }
    }
    //若未找到target元素，返回-1
    return -1;
}
```

```c
// (版本二) 左闭右开区间 [left, right)
int search(int* nums, int numsSize, int target){
    int length = numsSize;
    int left = 0;
    int right = length;	//定义target在左闭右开的区间里，即：[left, right)
    int middle = 0;
    while(left < right){  // left == right时，区间[left, right)属于空集，所以用 < 避免该情况
        int middle = left + (right - left) / 2;
        if(nums[middle] < target){
            //target位于(middle , right) 中为保证集合区间的左闭右开性，可等价为[middle + 1,right)
            left = middle + 1;
        }else if(nums[middle] > target){
            //target位于[left, middle)中
            right = middle ;
        }else{	// nums[middle] == target ，找到目标值target
            return middle;
        }
    }
    //未找到目标值，返回-1
    return -1;
}
```

### 双指针

### 滑动窗口

+ 滑动窗口也是双指针法的一种。
  典型题目：
  [长度最小的子数组](https://programmercarl.com/0209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE)

## 链表

+ 单链表/双链表/循环链表
+ 不同于数组的连续分布，链表在内存中离散分布，通过指针链接
+ **题中如果涉及头节点和其他节点的操作不统一，可以使用dummy节点，简化代码**
+ 链表增删（按index或者value）只用一个指针即可
+ 双指针
  + 单向链表如果涉及反向的回溯，需要两个个甚至多个指针保存前值
    + [翻转链表](https://programmercarl.com/0206.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.html#%E6%80%9D%E8%B7%AF)
    + [两两交换链表中的节点](https://programmercarl.com/0024.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE)
  + [删除链表的倒数第N个节点](https://programmercarl.com/0019.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9.html)
  + [链表相交](https://programmercarl.com/%E9%9D%A2%E8%AF%95%E9%A2%9802.07.%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4.html)
  + [环形链表II](https://programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE)

## 哈希表
+ **使用数组来做哈希的题目，是因为题目都限制了数值的大小。而且如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费,可以用C语言的uthash**
  + [两数之和](https://programmercarl.com/0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE)
  + [四数相加II](https://programmercarl.com/0454.%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0II.html)
+ uthash支持C语言的任意数据类型做为key值，无论是基本数据类型还是自定义的struct，但是不同类型的key其操作接口方式略有不同，而且它甚至可以采用多个值作为key
+ leetcode已包含了uthash.h,可以直接使用

| macro            | arguments                                          |
| ---------------- | -------------------------------------------------- |
| HASH_ADD_INT     | (head, keyfield_name, item_ptr)                    |
| HASH_REPLACE_INT | (head, keyfield_name, item_ptr, replaced_item_ptr) |
| HASH_FIND_INT    | (head, keyfield_name, item_ptr, replaced_item_ptr) |
| HASH_ADD_STR     | (head, keyfield_name, item_ptr)                    |
| HASH_REPLACE_STR | (head, keyfield_name, item_ptr, replaced_item_ptr) |
| HASH_FIND_STR    | (head, key_ptr, item_ptr)                          |
| HASH_ADD_PTR     | (head, keyfield_name, item_ptr)                    |
| HASH_ADD_PTR     | (head, keyfield_name, item_ptr, replaced_item_ptr) |
| HASH_FIND_PTR    | (head, key_ptr, item_ptr)                          |
| HASH_DEL         | (head, item_ptr)                                   |
| HASH_SORT        | (head, cmp)                                        |
| HASH_COUNT       | (head)                                             |

```c
#include <stdio.h>
#include <stdlib.h>
#include "uthash.h"
/* 'uthash' can be used for !!!Hash!!! and !!!Map!!! */


typedef struct {
    int id;  /* key */
    char name[10];
    UT_hash_handle hh;  /* make this structure hashable */
} HashTable, HashItem;

HashTable *hash_table = NULL;  /* important! initialize to NULL */

HashItem *findItem(int id)
{
    HashItem *item;
    HASH_FIND_INT(hash_table, &id, item);
    return item;
}

void addItem(int id, char *name)
{
    HashItem *item = NULL;
    HASH_FIND_INT(hash_table, &id, item);  /* check existence of this id */
    if (item == NULL) {
        item = (HashItem *)malloc(sizeof(HashItem));
        item->id = id;
        HASH_ADD_INT(hash_table, id, item);  /* id: name of key field, cause HASH_ADD_INT is a macro function */
    }
    strcpy(item->name, name);
}

void deleteItem(HashItem *item)
{
    /* item: the addr of item to delete. you must key -> HASH_FIND_INT() -> pointer(addr) -> HASH_DEL() */
    HASH_DEL(hash_table, item);
    free(item);
}

void printAll()  /* traversal methods 1 */
{
    HashItem *current_item = NULL, *tmp = NULL;
    int index = 0;

    HASH_ITER(hh, hash_table, current_item, tmp) {
        printf("index: %d, id: %d, name: %s\n", index++, current_item->id, current_item->name);
    }
}

void printAllKeys()  /* traversal methods 2 */
{
    HashItem *item = NULL;
    int index = 0;

    for (item = hash_table; item != NULL; item = item->hh.next) {
        printf("index: %d, id: %d\n", index++, item->id);
    }
    /* it's a doubly linked list with hh.next and hh.prev */
}

int length()
{
    return HASH_COUNT(hash_table);
}

int idSortFunc(HashItem *a, HashItem *b)
{
    return a->id - b->id;
}

void sortById()
{
    HASH_SORT(hash_table, idSortFunc);
}

void deleteAll()
{
    HASH_CLEAR(hh, hash_table);
    /* now 'hash_table' points to NULL */
}


int main(int argc, char *argv[])
{
    addItem(3, "0003");
    addItem(0, "0000");
    addItem(1, "0001");
    addItem(2, "0002");
    deleteItem(findItem(2));
    printAll();
    printAllKeys();
    printf("now HASH length is %d\n", length());

    sortById();
    printAll();

    deleteAll();
    printf("succeed!\n");
    return 0;
}

/* struct key type <-> FIND        <-> ADD
 * int              | HASH_FIND_INT | HASH_ADD_INT
 * char *           | HASH_FIND_STR | HASH_ADD_KEYPTR(hh, hash_table, item->id, strlen(item->id), item)
 * char[]           | HASH_FIND_STR | HASH_ADD_STR
 * void *           | HASH_FIND_PTR | HASH_ADD_PTR
 */

```

## 字符串
+ 字符串题目的做法一般和数组类型差不多，本质是一个字符数组。
+ 在C语言中，把一个字符串存入一个数组时，也把结束符 '\0'存入数组，并以此作为该字符串是否结束的标志。内存分配时一定要多分配一个字节保存'\0'
+ strlen()获取的字符串长度不包含结束符
+ 
## 双指针法

## 栈与队列

## 二叉树

## 回溯

## 贪心

## 图

### 深度搜索

### 广度搜索

## 动态规划(略)

## 参考资料

+ [代码随想录](https://programmercarl.com/other/say_feel.html)
